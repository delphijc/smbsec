# Chapter 4 – Automated Incident Response

## 4.1 The Incident-Response Lifecycle

Incident Response (IR) is a race against time. The standard lifecycle, as defined by frameworks like NIST, provides a roadmap for winning that race.

1.  **Detection:** The process starts with a signal—an alert generated by our AI-driven pipeline indicating a potential security event.
2.  **Triage:** Not all alerts are created equal. Automated systems score and enrich alerts to prioritize them, separating critical incidents from noise.
3.  **Containment:** This is the "stop the bleeding" phase. Automated playbooks can take immediate action, such as blocking a malicious IP address at the firewall or isolating a compromised host from the network.
4.  **Eradication:** Once contained, the threat must be removed. This involves deleting malware, patching vulnerabilities, or re-imaging infected systems.
5.  **Recovery:** Systems are restored to normal operation. Integrity checks ensure that the threat is truly gone before business resumes.
6.  **Lessons Learned:** Finally, a post-mortem analysis is conducted. What happened? How did we respond? What can we do better next time? This knowledge feeds back into the system to improve future responses.

## 4.2 Playbook Generation with Stable-Baselines3

Static playbooks are brittle; they can't adapt to the nuance of every unique attack. We can use **Reinforcement Learning (RL)** to build dynamic, adaptive response agents.

*   **Reinforcement Learning (RL):** We train an RL agent using **Stable-Baselines3**. The agent learns by trial and error in a simulated environment, discovering the optimal sequence of actions to mitigate a threat.
*   **State Representation:** The "state" of the incident is fed to the agent as a vector. This includes alert metadata (severity, source), IOC context (threat actor, malware family), and system telemetry (CPU usage, active connections).
*   **Action Space:** The agent chooses from a defined set of actions: "Block IP," "Quarantine Host," "Kill Process," "Run Antivirus Scan," or "Escalate to Analyst."
*   **Reward Function:** The agent is guided by a reward function. It gets points for minimizing the **Time to Containment** and preventing damage, but loses points for disrupting legitimate business operations (false positives).
*   **Deployment:** Once trained, the policy is saved and exposed via a REST API. When a real incident occurs, the system queries this API to get the best next step.

## 4.3 Integration with Wazuh

**Wazuh** is the muscle of our response system. It provides the mechanism to execute the actions decided by our AI brain.

*   **Rule Engine:** Wazuh's powerful rule engine can trigger specific responses based on log data. For example, if it sees 5 failed login attempts in 1 minute, it can trigger a "brute force" rule.
*   **Active Response:** This is Wazuh's killer feature. It can automatically execute scripts on endpoints in response to alerts. We can configure it to run `iptables` commands to drop traffic, add entries to `/etc/hosts.deny`, or even shut down a network interface.
*   **Correlation:** Wazuh doesn't work in a vacuum. Its alerts are forwarded to **Elastic SIEM**, ensuring that these automated actions are visible to the broader SOC and correlated with other events.
*   **Feedback Loop:** The outcomes of Wazuh's actions—"Did the attack stop?"—are logged and fed back into the RL training pipeline. If an action failed to contain the threat, the agent learns to try something else next time.

## 4.4 OpenCTI for Threat Context

**OpenCTI** ensures our automated responses are informed by global intelligence, not just local data.

*   **Actor & Malware Mapping:** OpenCTI maps alerts to known threat actors and malware families. Knowing that an attack is from "APT29" vs. a "Script Kiddie" might dictate a different response strategy.
*   **Automated Playbook Augmentation:** The RL agent can query OpenCTI for context-specific actions. If OpenCTI knows that a specific malware variant communicates with a hardcoded list of C2 domains, the playbook can automatically block *all* of those domains, not just the one seen in the alert.
*   **Data Sharing:** Defense is a community effort. When our system confirms a new IOC, it can automatically push that data back into OpenCTI, sharing it with the broader security community.

## 4.5 Orchestration Layer

To make all these pieces work together, we need a conductor. A lightweight orchestration layer ties the detection, decision, and execution components together.

*   **SOAR-like Workflow:** A simple Python Flask application can serve as this orchestrator. It listens for webhooks from Elastic SIEM.
*   **Webhook Endpoints:** When Elastic SIEM generates an alert, it posts the data to the orchestrator.
*   **Logic Flow:** The orchestrator first calls the **RL Service** to get the recommended action. It then translates that recommendation into a specific command and sends it to the **Wazuh API** to trigger an Active Response.
*   **Audit Trail:** Every step of this dance is logged to a PostgreSQL database. This ensures we have a complete audit trail for compliance and forensic investigations: "Alert received at T0, RL recommended 'Block IP' at T1, Wazuh executed block at T2."

## 4.6 Continuous Improvement

The goal is to build a system that learns and evolves.

*   **Model Retraining:** The RL agent's "experience replay buffer"—its memory of past actions and rewards—is constantly updated. We periodically retrain the agent on this growing dataset to refine its policy.
*   **Human-in-the-Loop:** We must trust but verify. For high-stakes actions, the system can pause and request analyst approval. These human decisions are recorded and used for **Supervised Fine-Tuning**, teaching the agent to mimic the expert judgment of senior analysts.
*   **Metrics:** We measure success by the numbers. Key Performance Indicators (KPIs) include **Mean Time to Containment (MTTC)**, the **False-Positive Rate** of automated actions, and the reduction in **Analyst Effort** (time saved).

---

*This chapter shows how to turn detection into action by combining reinforcement learning, Wazuh’s active-response capabilities, and OpenCTI’s threat context into an automated, continuously improving incident-response workflow.*